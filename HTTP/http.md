## HTTP 协议

### 请求方法

GET`通过uri获取资源`, POST`用于添加新的内容`, PUT`用于修改某个内容`,DELETE`删除某个内容`, 

CONNECT`用于代理进行传输,例如使用ssl`, OPTIONS`询问可以执行哪些方法`, PATCH`部分文档修改`, PROFIND`查看属性`, 

COPY`拷贝`, MOVE`移动`, LOCK`加锁`, UNLOCK`解锁`, TRACE`远程诊断服务器`, 

HEAD`类似get但不返回数据,用于检索数据, 返回数据元信息`

### URL和URI的区别

URI 是统一资源标识符, URL 是统一资源定位符, URN 是统一资源名称

URI = URL + URN  (范围)

### 客户端请求格式

三部分

> 请求方法   URI   版本
>
> 请求头
>
> 请求正文(数据, 一般POST数据在这里, GET请求这里是空的)

### 通用头字段(请求和响应均可)

| 字段          | 意思                                                         |
| ------------- | ------------------------------------------------------------ |
| Cache-Control | no-cache:客户端或者此数据不允许缓存<br />no-store:缓存应该尽快从存储器删除文档所有痕迹<br />max-age:缓存持续时间<br />public: 允许代理服务器和客户端缓存<br />private: 只允许客户端缓存<br />min-fresh:至少在未来n秒内缓存保持新鲜 |
| Connection    | close: 完成此次传输后断开连接<br />keepalive: 表示完成后不要断开,等待后续请求<br />Keep-Alive: 表示持续连接时间 |
| Date          | 消息发送的时间                                               |



### 请求头字段表格

| 字段              | 意思                                                         |
| ----------------- | ------------------------------------------------------------ |
| Accept            | 表示客户端可以接收的资源类型, text/image/html等几种常用类型  |
| Accept-Charset    | 指定浏览器可以显示的字符集                                   |
| Accept-Encoding   | 浏览器支持的编码类型, gzip或compress是常见的                 |
| Accept-Language   | 客户端首选语言                                               |
| Authorization     | 客户端在访问受密码保护的网页时验证自己的身份                 |
| Connection        | 表示客户端是否可以持久连接, 设置为keep-alive                 |
| Content-Length    | 只用于POST请求, 并提供POST数据大小                           |
| Cookie            | 请求时带上客户端Cookie, 就是在这里                           |
| Host              | 指定信息的URL和端口                                          |
| If-Modified-Since | 在客户端保存的信息超过了服务器预设的过期时间, 设置这个属性, 如果服务端资源未更新, 则返回304, 当客户端访问页面时，服务器会将页面最后修改时间通过 Last-Modified 标识由服务器发往客户端，客户端记录修改时间，再次请求本地存在的cache页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的最后修改时间戳发送回去，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则 返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了，这样在网络上传输的数据就会大大减少，同时也减轻了服务器的负担 |
| User-Agent        | 识别浏览器客户端以及其他客户端                               |

### 响应头字段表格

| 字段           | 意思                                                         |
| :------------- | ------------------------------------------------------------ |
| Age            | 当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了 |
| Server         | 服务端是什么服务器软件￼￼￼￼￼￼<br/>字段	意思<br/>Accept	表示客户端可以接收的资源类型, text/image/html等几种常用类型<br/>Accept-Charset	指定浏览器可以显示的字符集<br/>Accept-Encoding	浏览器支持的编码类型, gzip或compress是常见的<br/>Accept-Language	客户端首选语言<br/>Authorization	客户端在访问受密码保护的网页时验证自己的身份<br/>Connection	表示客户端是否可以持久连接, 设置为keep-alive<br/>Content-Length	只用于POST请求, 并提供POST数据大小<br/>Cookie	请求时带上客户端Cookie, 就是在这里<br/>Host	指定信息的URL和端口<br/>If-Modified-Since	在客户端保存的信息超过了服务器预设的过期时间, 设置这个属性, 如果服务端资源未更新, 则返回304, 当客户端访问页面时，服务器会将页面最后修改时间通过 Last-Modified 标识由服务器发往客户端，客户端记录修改时间，再次请求本地存在的cache页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的最后修改时间戳发送回去，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则 返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了，这样在网络上传输的数据就会大大减少，同时也减轻了服务器的负担<br/>User-Agent	识别浏览器客户端以及其他客户端￼￼￼￼￼￼<br/>字段	意思<br/>Accept	表示客户端可以接收的资源类型, text/image/html等几种常用类型<br/>Accept-Charset	指定浏览器可以显示的字符集<br/>Accept-Encoding	浏览器支持的编码类型, gzip或compress是常见的<br/>Accept-Language	客户端首选语言<br/>Authorization	客户端在访问受密码保护的网页时验证自己的身份<br/>Connection	表示客户端是否可以持久连接, 设置为keep-alive<br/>Content-Length	只用于POST请求, 并提供POST数据大小<br/>Cookie	请求时带上客户端Cookie, 就是在这里<br/>Host	指定信息的URL和端口<br/>If-Modified-Since	在客户端保存的信息超过了服务器预设的过期时间, 设置这个属性, 如果服务端资源未更新, 则返回304, 当客户端访问页面时，服务器会将页面最后修改时间通过 Last-Modified 标识由服务器发往客户端，客户端记录修改时间，再次请求本地存在的cache页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的最后修改时间戳发送回去，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则 返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了，这样在网络上传输的数据就会大大减少，同时也减轻了服务器的负担<br/>User-Agent	识别浏览器客户端以及其他客户端, 及版本信息 |
| Accepts-Ranges | WEB服务器表明自己是否接受获取其某个实体的一部分(比如文件的一部分)的请求<br />bytes：表示接受，none：表示不接受 |
| Vary           | WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求 |



## 状态码

- 1XX `临时响应`
  - 100
  - 101 `切换协议`
- 2XX `成功`
  - 200 成功, 服务器正常返回内容
  - 201 请求成功并且在服务器创建了资源
  - 202 服务器接受请求, 但未处理
  - 203 非授权信息, 服务器已经返回了信息, 但是返回信息可能来自其他来源
  - 204 成功处理但无内容
  - 205 重置服务
  - 206 返回部分内容
- 3XX `重定向`
  - 301 永久重定向
  - 302 暂时重定向
  - 304 资源未修改, 查找缓存
  - 307 临时性重定向, 这个资源来自别处, 但浏览器下一次还请求这个资源
- 4XX `客户端错误`
  - 400 错误请求
  - 401 未授权
  - 403 禁止
  - 404 找不到资源
  - 405 方法禁用
- 5XX `服务器错误`
  - 500 服务器内部错误
  - 501 服务器不具备完成请求的功能
  - 503 服务器不可用
  - 504 网关超时
  - 505 http 版本不被支持

## HTTP 1.0 和 HTTP 1.1 区别

1. 增加请求方法
2. 增加长链接
3. 缓存的丰富处理
4. 增加多个响应码

## HTTP 2.0 协议

### 二进制传输

> 在之前的 Http 协议中, 数据通过文本的形式传输, 在 2.0 中采取新的编码格式, 所有数据都会被切割, 并采取二进制代码

### 多路复用

> 在 2.0 中有两个非常重要的概念, **帧和流**, 每一帧会标记属于哪个流, 在一个 TCP 链接中可以存在多个流, 也就是发送多个请求, 避免旧版本的队头阻塞问题, 极大的提升性能

### Header 压缩

> 在老版本里面, 因为 cookie, 每一次传输都会携带很重的头, 在 2.0 进行头部压缩, 使用 hpack 格式
>
> 在两端维护了索引表, 用于存储已存在的 header 键名, 后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值.

### Server Push

> 在 HTTP/2 中, 服务端可以在客户端某个请求后, 主动推送其他资源
>
> 可以想象以下情况, 某些资源客户端是一定会请求的, 这时就可以采取服务端 push 的技术, 提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间. 当然在浏览器兼容的情况下你也可以使用 prefetch .



## QUIC 协议 ( from Google )

> 主要是 TCP 的问题, 多路复用可能导致一个域名下只存在一个连接, 但是万一出现丢包现象, 所有的请求都会等待这个包的重新传输, 这就尴尬了...
>
> 谷歌基于 UDP 研究出 QUIC

## GET和POST有什么区别？ 

- 数据传输⽅式不同：GET请求通过URL传输数据，⽽POST的数据通过请求体传输。 
- 安全性不同：POST的数据因为在请求主体内，所以有⼀定的安全性保证，⽽GET的数据在URL中，通过历史记 录，缓存很容易查到数据信息。 
- 数据类型不同：GET只允许 ASCII 字符，⽽POST⽆限制 
- GET⽆害： 刷新、后退等浏览器操作GET请求是⽆害的，POST可能重复提交表单 
- 特性不同：GET是安全（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化）且幂等（幂等的 概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同），⽽POST是⾮安全⾮幂等bilibl

## PUT和POST都是给服务器发送新增资源，有什么区别？ 

- PUT⽅法是幂等的：连续调⽤⼀次或者多次的效果相同（⽆副作⽤），⽽POST⽅法是⾮幂 等的。 
- 除此之外还有⼀个区别，通常情况下，PUT的URI指向是具体单⼀资源，⽽POST可以指向资源集合。 举个例⼦，我们在开发⼀个博客系统，当我们要创建⼀篇⽂章的时候往往⽤ POST https://www.jianshu.com/articles ， 这个请求的语义是，在articles的资源集合下创建⼀篇新的⽂章，如果我们多次提交这个请求会创建多个⽂章，这是⾮幂 等的。 ⽽ PUT https://www.jianshu.com/articles/820357430 的语义是更新对应⽂章下的资源（⽐如修改作者名称等），这个 URI指向的就是单⼀资源，⽽且是幂等的，⽐如你把『刘德华』修改成『蔡徐坤』，提交多少次都是修改成『蔡徐坤』 
- ps: 『POST表示创建资源，PUT表示更新资源』这种说法是错误的，两个都能创建资源，根本区别就在于幂等性





